#!/usr/bin/env python3

# haplo_merge.py

'''
A python script to parse and merge two haplotype VCFs into a diploid VCF
VCFs have to be generated by PMDV and only PASS variants are processed
Sequencing data has to be PCR amplicons

Merges VCF records based on columns 1 to 5
When a match is found, records are merged with the following instructions:
1. Same columns 1 to 5
2. QUAL scores are averaged
3. INFO value will correspond to that of haplotype 1
4. GQ is updated according to averaged QUAL
5. DP is summed
6. AF is averaged

If a match is not found, records will be observed as heterozygous and only the GT, DP, and AF will be modified accordingly (GT: 1|0 or 0|1, DP: Total read depth, AF: reads with variant/DP)
'''

# Import packages
import os
import sys
from sys import argv
import pysam
import statistics

__version__ = '0.0.1'

# Main function
def haplomerge(vcf1, vcf2):
    v1 = pysam.VariantFile(vcf1)
    v2 = pysam.VariantFile(vcf2)
    v1_dict = get_records(v1)
    v2_dict = get_records(v2)
    total_dp = calculate_dp(v1_dict, v2_dict)
    merged_list = analyse_records(v1_dict, v2_dict)
    final_out = []
    for i in v1_dict:
        final_out.append(modify_records_hetero(v1_dict[i], 1, total_dp))
    for i in v2_dict:
        final_out.append(modify_records_hetero(v2_dict[i], 2, total_dp))
    for i in merged_list:
        final_out.append(i)
    merged_header = merge_header(v1, v2)
    print('\n'.join(merged_header))
    print('\n'.join(final_out))

def merge_header(v1, v2):
    h1 = str(v1.header).split('\n')
    h2 = str(v2.header).split('\n')
    h1 = list(filter(None, h1))
    h2 = list(filter(None, h2))
    repeat = []
    final = []
    for i in h1[:-1]:
        _line = i.split(',', 1)[0]
        if  _line not in repeat:
            repeat.append(_line)
            final.append(i)
    for i in h2[:-1]:
        _line = i.split(',', 1)[0]
        if  _line not in repeat:
            repeat.append(_line)
            final.append(i)
    final.append(h1[-1])
    return final

def merge_records_homo(rec1, rec2):
    fmt_dict1, _format1 = parse_format(rec1)
    fmt_dict2, _format2 = parse_format(rec2)
    new_fmt = {}
    avg_qual = int((int(rec1.split('\t')[5]) + int(rec2.split('\t')[5]))/2)
    new_fmt['GQ'] = int(avg_qual)
    merged_info = rec1.split('\t')[7]
    # total_dp = int(rec1.split('\t')[9].split(':')[2]) + int(rec2.split('\t')[9].split(':')[2])
    # avg_af = round((float(rec1.split('\t')[9].split(':')[3]) + float(rec2.split('\t')[9].split(':')[3]))/2, 3)
    new_fmt['VAF'] = round((float(fmt_dict1['VAF']) + float(fmt_dict2['VAF']))/2, 3)
    new_fmt['AD'] = int((float(fmt_dict1['AD']) + float(fmt_dict2['AD']))/2)
    new_fmt['DP'] = int(float(fmt_dict1['DP']) + float(fmt_dict2['DP']))
    try:
        new_fmt['AP'] = round((float(fmt_dict1['AP']) + float(fmt_dict2['AP']))/2, 6)
    except KeyError:
        if 'AP' in fmt_dict1:
            new_fmt['AP'] = fmt_dict1['AP']
        elif 'AP' in fmt_dict2:
            new_fmt['AP'] = fmt_dict2['AP']
        else:
            new_fmt['AP'] = ''
    merged_sam = ["1/1"]
    for i in _format1[1:]:  # Loop append format except GT
        try:
            merged_sam.append(str(new_fmt[i]))
        except KeyError:
            merged_sam.append(str(fmt_dict1[i]))
    new_rec = '\t'.join(rec1.split('\t')[0:5]) + '\t' + str(avg_qual) + '\tPASS\t' + merged_info + '\t' + ':'.join(_format1) + '\t' + ':'.join(merged_sam)
    return new_rec

def modify_records_hetero(rec, haplotype, total_dp):
    fmt_dict, _format = parse_format(rec)
    fmt_dict['DP'] = total_dp
    fmt_dict['VAF'] = round(float(fmt_dict['AD'])/total_dp, 3)
    if haplotype == 1:
        modified_sam = ["1|0"]
    elif haplotype == 2:
        modified_sam = ["0|1"]
    for i in _format[1:]:  # Loop append format except GT
        modified_sam.append(str(fmt_dict[i]))
    return '\t'.join(rec.split('\t')[0:9]) + '\t' + ':'.join(modified_sam)

def get_records(vcf):
    n = 0
    vcf_dict = {}
    for rec in vcf.fetch():
        rec_s = str(rec)
        if rec_s.split('\t')[6] == 'PASS':
            vcf_dict[n] = rec_s
        n += 1
    return vcf_dict

def calculate_dp(v1_dict, v2_dict):
    dp1 = []
    dp2 = []
    for i in v1_dict:
        fmt_dict, _ = parse_format(v1_dict[i])
        dp1.append(int(fmt_dict['DP']))
    for i in v2_dict:
        fmt_dict, _ = parse_format(v2_dict[i])
        dp2.append(int(fmt_dict['DP']))
    return int(statistics.mean(dp1) + statistics.mean(dp2))

def parse_format(rec):
    fmt_dict = {}
    _format = rec.split('\t')[8].split(':')
    sam = rec.split('\t')[9].split(':')
    sam[-1] = sam[-1].strip()
    for j, k in zip(_format, sam):
        fmt_dict[j] = k
    return fmt_dict, _format

def analyse_records(v1_dict, v2_dict):
    merged_list = []
    v1_repeated = []
    for i in v1_dict:
        for j in v2_dict:
            # if VCF record matches
            if v1_dict[i].split('\t')[0:5] == v2_dict[j].split('\t')[0:5]:
                merged_list.append(merge_records_homo(v1_dict[i], v2_dict[j]))
                v1_repeated.append(i)
                v2_dict.pop(j)
                break
    for i in v1_repeated:
        v1_dict.pop(i)
    return merged_list

if __name__ == '__main__':
    if len(argv) != 3:
        sys.exit("Input Error - usage: python haplo_merge.py haplotype_1.vcf haplotype_2.vcf > diploid.vcf")

    vcf1 = argv[1]
    vcf2 = argv[2]
    haplomerge(vcf1, vcf2)
